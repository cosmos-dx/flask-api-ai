{
    "ac620677-2c9a-4fc5-85e1-f69a642932fc": {
        "resume": "Surya Pratap Singh Chauhan\n(+91) 9305738812 | surya.pratap0038@gmail.com | linkedin.com/in/spsc | brodante.github.io/portfolio\nExperience\nSoftware Development Engineer June 2024 \u2013 Present\nNimbus Gaming Jhansi, UP\n\u2022 Built companion software for peripherals, enabling user customization and seamless integration with firmware.\n\u2022 Helped develop firmware in C++ for wireless gaming mice with PAW3360 sensor, achieving stable 1000Hz polling\nrate, reducing driver size by 35%, and designing scalable architecture for PAW3395 sensor integration.\n\u2022 Led Rust firmware development, optimizing wireless performance and reducing load time by 10-15%.\nInfosec Writer July 2023 \u2013 July 2024\nMedium Self Employed\n\u2022 Authored 15+ cybersecurity articles, reaching 10,000+ readers and increasing engagement by 30% through tutorials\nand expert insights.\nNetwork Engineer Intern Feb 2023 \u2013 May 2023\nErnst & Young LLP New Delhi\n\u2022 Assisted in cybersecurity research and testing, identifying 13+ vulnerabilities using Burp Suite and Nmap, which\ncontributed to improving client data protection by up to 20%.\nProjects\nChinatsu in development | C++, GLFW, OpenGL, Glad, ImGui, premake, Box2D, spdlog 2024 \u2013 Present\n\u2022 Designing and implementing a game engine from scratch in C++ for Windows, focusing on custom graphics\nrendering, input systems, and real-time game development.\n\u2022 Integrating GLFW for window management and input, OpenGL for rendering, and ImGui for custom debugging\ntools and development interfaces. GitHub: brodante/Chinatsu\nSignOutSync in beta | Python, JavaScript 2024 \u2013 Present\n\u2022 Developing a Single Logout system that allows users to view and manage active logins across devices, as well as\nsubmit remote logout requests for compromised accounts and devices.\n\u2022 GitHub: brodante/SignOutSync, qualified for HacktoberFest 2024.\nKeyGuardian Developed, Maintained | Python(zlib, hashlib, fernet), C++ 2023 \u2013 2024\n\u2022 Python tool for hash creation, file/folder encryption, and decryption using Fernet (AES in CBC mode with a\n128-bit key), securely retrieving keys from default or specified directories for data decryption.\n\u2022 Github: brodante/KeyGuardian, Published Research Paper DOI: 10.55041/IJSREM34392\nSkills\nLanguages: C/C++, Python\nTools & Platforms: Visual Studio, VS Code, Burp Suite, OWASP ZAP, Nmap, sqlmap, Linux, Git, Postman\nFrameworks & Libraries: Metasploit, Fernet, Cryptopp, STL, fstream, system.OS\nSoft Skills: Adaptability, Curiosity, Analytical Thinking, Problem-Solving\nCertifications\nDIAT Certified Information Assurance Professional Verify.\nEthical Hacker by CISCO Verify.\nCyber Threat Management by CISCO Verify.\nIT Security Defense against the digital dark arts by Google Verify.\nAutomate Cybersecurity Tasks with Python by Google Verify.\nPut It to Work: Prepare for Cybersecurity Jobs by Google Verify.\nOperating Systems: Overview, Administration, and Security by IBM Verify.\nEducation\nRaj Kumar Goel Institute of Technology Ghaziabad, U.P\nBachelor of Technology in Computer Science and Engineering Nov. 2020 \u2013 July 2024\nLucknow Public School Lucknow, U.P.\nSenior Secondary Education (Class XII) 2017 \u2013 2019\n",
        "questions_list": [
            "Can you walk me through your resume, highlighting the projects and experiences that you find most relevant to this backend developer position?",
            "Your resume mentions working on firmware development in C++ for gaming mice. Can you describe the challenges you faced in reducing the driver size by 35% and how you overcame them?",
            "You've developed SignOutSync, a single logout system.  Could you explain the architecture of this system, focusing on how you handled secure communication and remote logout requests across different devices?",
            "Your experience includes using various security tools like Burp Suite and Nmap. Describe a scenario where you used these tools to identify and report a vulnerability.  What was the vulnerability, how did you find it, and what was the impact of your findings?",
            "Your KeyGuardian project involved file encryption and decryption.  Explain your choice of using Fernet (AES in CBC mode) for encryption. What are the tradeoffs of this choice, and how did you handle key management and secure storage?",
            "You mention experience with both C++ and Python.  Imagine you need to design a highly scalable and efficient backend service. Would you choose C++ or Python, and why?  Consider factors like performance, maintainability, and development speed in your answer."
        ],
        "qna": [
            {
                "question": "Can you walk me through your resume, highlighting the projects and experiences that you find most relevant to this backend developer position?",
                "answer": "As you can see from my resume, my experience as a Software Development Engineer at Nimbus Gaming involved significant backend work, particularly in developing firmware in C++ for wireless gaming mice, optimizing performance, and designing scalable architectures. Furthermore, my project SignOut Sync demonstrates my ability to build cross-device synchronization tools and handle secure remote requests, showcasing skills relevant to backend development. Finally, the KeyGuardian project, a Python and C++ tool for encryption and decryption, highlights my understanding of data security and management, crucial aspects of backend roles."
            },
            {
                "question": "That's a good start.  Can you elaborate on the architecture you designed for the PAW3395 sensor integration in the Nimbus Gaming project? What design patterns or technologies did you use to ensure scalability?",
                "answer": "For the PAW3395 sensor integration, I designed a modular architecture in C++ employing abstraction layers to isolate hardware-specific code and an event-driven model for efficient asynchronous event handling, ensuring scalability through generic interface design, efficient data structures like circular buffers, and a flexible configuration management system to accommodate future sensor upgrades and feature additions."
            },
            {
                "question": "That's a good high-level overview. Can you elaborate on the specific data structures used in the circular buffer?  What were the performance considerations that led you to choose that approach, and how did you handle potential buffer overflows?",
                "answer": "For the PAW3395 sensor integration, the circular buffer was implemented using a standard array to store the incoming sensor data, paired with two integer pointers: 'head' to track where to write the next data point, and 'tail' to track where to read the next data point.  This array-based structure was chosen for its efficiency in providing constant-time access to elements, a critical factor for the high-speed data acquisition required by the sensor.  The primary performance consideration was to minimize overhead; traditional data structures would incur costs from memory reallocation or data copying, which the circular buffer avoids by design. When the buffer reaches its capacity, new data overwrites the oldest data, ensuring that the most recent information is always available. To manage this, I also included flags and counters to monitor how often the buffer overflows, which aids in debugging and allows for potential dynamic adjustments to the buffer size."
            },
            {
                "question": "Your resume mentions working on firmware development in C++ for gaming mice. Can you describe the challenges you faced in reducing the driver size by 35% and how you overcame them?",
                "answer": "To reduce the driver size by 35%, I optimized the C++ firmware through code analysis and rewriting for efficiency, improved memory management, removed redundant code, applied data compression techniques, and utilized compiler optimization flags."
            },
            {
                "question": "That's a good overview. Can you elaborate on a specific example of redundant code you removed, and what techniques you used to identify it?  For instance, did you use static analysis tools, code reviews, or a combination of approaches?",
                "answer": "To identify redundant code, I primarily used a combination of manual code reviews and static analysis tools; for example, I discovered several instances where identical data processing loops were repeated across different sensor data filtering functions, and by refactoring these into a single, parameterized function, I eliminated the redundancy, significantly reducing the code footprint."
            },
            {
                "question": "That's a good start. Can you elaborate on the specific static analysis tools you used and what metrics they provided to help you identify these redundant loops?  For example, did the tools highlight code clones or similar code structures?",
                "answer": "To effectively reduce firmware size, I utilized static analysis tools such as Cppcheck and Visual Studio's built-in code analysis, which were instrumental in providing key metrics; these tools specifically offered code clone detection to pinpoint identical or near-identical code blocks, measured cyclomatic complexity to identify overly complex functions that often contained redundancies, and generated detailed reports on duplicated code, enabling me to systematically refactor and eliminate inefficiencies."
            },
            {
                "question": "You've developed SignOutSync, a single logout system.  Could you explain the architecture of this system, focusing on how you handled secure communication and remote logout requests across different devices?",
                "answer": "For SignOutSync, I designed a centralized architecture with a server-side component built using Python to manage active user sessions and device information, while client-side components in JavaScript, embedded in web applications or native apps, communicate with this server. Secure communication is ensured through HTTPS for all data transmission and JWTs for authenticating and authorizing requests between clients and the server. Remote logout requests are handled by the server invalidating the specific session token, which is then propagated to all connected clients, effectively logging the user out from all devices."
            },
            {
                "question": "That's a good overview.  Can you elaborate on how you handle the scenario where a user's device is offline when a remote logout request is issued?  How do you ensure the logout is eventually applied when the device comes back online?",
                "answer": "To handle offline devices in SignOutSync, the server flags the user's session as invalid upon a remote logout request and stores this status persistently; when a device comes back online, it periodically polls the server for session status, and upon receiving the invalid status, enforces the logout locally, ensuring eventual consistency across all devices."
            },
            {
                "question": "That's a good start.  Can you elaborate on the mechanism for persistent storage of the invalid session status on the server?  What happens if the server itself is down?",
                "answer": "For persistent storage of invalidated session status in SignOutSync, I utilized PostgreSQL for its reliability, ensuring data preservation across server restarts, and implemented redundancy and failover mechanisms with multiple server instances and database replication to maintain system availability even during server downtime."
            },
            {
                "question": "Your experience includes using various security tools like Burp Suite and Nmap. Describe a scenario where you used these tools to identify and report a vulnerability.  What was the vulnerability, how did you find it, and what was the impact of your findings?",
                "answer": "While conducting security testing, I utilized Burp Suite to intercept and manipulate web requests, which allowed me to identify an SQL injection vulnerability in a web application's login form; this vulnerability could have enabled an attacker to bypass authentication and gain unauthorized access to the database, potentially leading to data breaches, and by reporting this finding, I contributed to significantly improving client data protection."
            },
            {
                "question": "That's a good start. Can you elaborate on the specific HTTP request you intercepted and manipulated?  What was the SQL injection payload you used, and how did Burp Suite help you confirm the vulnerability?  Also, what remediation steps did you suggest?",
                "answer": "During security testing, I used Burp Suite to intercept and manipulate the HTTP POST request to a web application's login endpoint, injecting the SQL payload  OR 1 = 1 -- into the password field. Burp Suite's proxy allowed me to modify and resend the request, and by analyzing the server's response, I confirmed an SQL injection vulnerability. This vulnerability could have allowed unauthorized database access and potential data breaches. To remediate this, I recommended using parameterized queries or prepared statements, implementing strict input validation, applying the principle of least privilege, and deploying a Web Application Firewall."
            },
            {
                "question": "Good, you identified a common SQL injection vulnerability. Can you elaborate on how you determined the specific database type and version from the server's response, and how that knowledge would inform your choice of remediation techniques?",
                "answer": "You're right, identifying the database is crucial for effective remediation! To determine the specific database type and version, I analyzed the server's responses for error messages or version banners, which databases sometimes reveal in response to specific queries or errors. For instance, certain SQL syntax errors or specific function calls are unique to particular database systems like MySQL, PostgreSQL, or Microsoft SQL Server, and the structure or content of standard error messages can also provide clues. Knowing the database type and version is vital because remediation techniques can vary significantly; for example, the syntax for parameterized queries differs between databases, and specific versions may have known vulnerabilities that need to be addressed with particular patches or configurations. This knowledge allows for more precise and effective security measures, ensuring the application is robust against SQL injection and other database-related attacks."
            },
            {
                "question": "Your KeyGuardian project involved file encryption and decryption.  Explain your choice of using Fernet (AES in CBC mode) for encryption. What are the tradeoffs of this choice, and how did you handle key management and secure storage?",
                "answer": "For KeyGuardian, I chose Fernet (AES in CBC mode) due to its simplicity and security; it provides authenticated encryption, ensuring both confidentiality and integrity, which is crucial for file encryption. The trade-offs include the need for secure key management, as Fernet's security relies heavily on keeping the key secret, and while CBC mode is widely used, it requires proper initialization vectors to avoid certain attacks. I addressed key management by allowing users to securely retrieve keys from default or specified directories, enhancing security by not storing them directly within the application."
            },
            {
                "question": "That's a good overview.  However, you mentioned Fernet uses AES in CBC mode, but Fernet actually uses AES in CTR mode with a unique nonce for each encryption operation.  Can you explain why the use of CTR mode with a unique nonce enhances security over traditional CBC mode, and how you ensured nonce uniqueness in your implementation?",
                "answer": "For KeyGuardian, I selected Fernet, which uses AES in CTR mode, for its strong authenticated encryption capabilities, ensuring both data confidentiality and integrity, a crucial requirement for secure file handling; CTR mode's advantage over CBC lies in its resistance to certain attacks and its ability to perform encryption and decryption in parallel, thus improving performance, and Fernet itself handles nonce generation and management, incorporating it securely within the encrypted data to guarantee nonce uniqueness and prevent its reuse, simplifying secure key management while enhancing overall security."
            },
            {
                "question": "You correctly identified Fernet's use of CTR mode and its advantages over CBC.  However, can you elaborate on the specific attacks that CTR mode mitigates better than CBC, and how Fernet's internal nonce management ensures uniqueness beyond simply including it in the ciphertext?  For example, what happens if the nonce is accidentally repeated or compromised?",
                "answer": "You're pushing me to be precise, and that's important in security! CTR mode notably mitigates padding oracle attacks, which exploit vulnerabilities in how CBC mode handles padding, potentially allowing attackers to decrypt portions of the ciphertext; Fernet enhances nonce management by deriving the nonce as part of its key derivation process and including it within the encrypted token along with the ciphertext and HMAC, ensuring that it's not directly user-controlled and reducing the risk of accidental reuse.  If a nonce is repeated in CTR mode, it's catastrophic, as it allows an attacker to XOR the ciphertexts and potentially recover the plaintext, compromising confidentiality."
            },
            {
                "question": "You mention experience with both C++ and Python.  Imagine you need to design a highly scalable and efficient backend service. Would you choose C++ or Python, and why?  Consider factors like performance, maintainability, and development speed in your answer.",
                "answer": "For a highly scalable and efficient backend service, I would lean towards C++ if performance is the absolute top priority, as it allows for fine-grained control over memory management and system resources, leading to optimized execution; however, if the project emphasizes rapid development and maintainability, Python would be a strong contender due to its simpler syntax and extensive libraries, which can significantly speed up development and make the codebase easier to understand and maintain, though it generally comes with a performance trade-off compared to C++."
            },
            {
                "question": "That's a good starting point.  Can you elaborate on specific C++ techniques you'd use to achieve that high scalability, perhaps mentioning concurrency models or specific libraries you'd consider?",
                "answer": "For a highly scalable and efficient backend service using C++, I would employ asynchronous I/O with libraries like asio for handling concurrent connections, leverage multi-threading and thread pools for parallel task execution, optimize memory management with custom allocators, utilize efficient data structures from the STL, and design the service to be stateless to facilitate scaling across multiple instances."
            },
            {
                "question": "That's a solid overview.  Can you elaborate on how you'd handle potential race conditions or deadlocks when using multi-threading and thread pools in this context, and what strategies you'd employ for efficient inter-thread communication?",
                "answer": "To handle race conditions and deadlocks in a multi-threaded C++ backend, I'd employ techniques like mutexes and locks for protecting shared resources, use atomic operations for simple state management, and design resource allocation strategies to prevent circular dependencies; for efficient inter-thread communication, I'd utilize thread-safe queues for passing messages or data between threads and consider condition variables for signaling and waiting on specific conditions, ensuring synchronized and safe interactions."
            }
        ],
        "question_index": 6,
        "current_answer": "",
        "current_question": "",
        "subquestion": "",
        "subquestion_count": 0,
        "job_description": "",
        "satisfactory_till_now": true,
        "current_subquestion": ""
    }
}