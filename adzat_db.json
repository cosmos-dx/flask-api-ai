{
    "1037b16b-50a6-46a6-b4f7-625fba5fddf2": {
        "resume": "Surya Pratap Singh Chauhan\n(+91) 9305738812 | surya.pratap0038@gmail.com | linkedin.com/in/spsc | brodante.github.io/portfolio\nExperience\nSoftware Development Engineer June 2024 \u2013 Present\nNimbus Gaming Jhansi, UP\n\u2022 Built companion software for peripherals, enabling user customization and seamless integration with firmware.\n\u2022 Helped develop firmware in C++ for wireless gaming mice with PAW3360 sensor, achieving stable 1000Hz polling\nrate, reducing driver size by 35%, and designing scalable architecture for PAW3395 sensor integration.\n\u2022 Led Rust firmware development, optimizing wireless performance and reducing load time by 10-15%.\nInfosec Writer July 2023 \u2013 July 2024\nMedium Self Employed\n\u2022 Authored 15+ cybersecurity articles, reaching 10,000+ readers and increasing engagement by 30% through tutorials\nand expert insights.\nNetwork Engineer Intern Feb 2023 \u2013 May 2023\nErnst & Young LLP New Delhi\n\u2022 Assisted in cybersecurity research and testing, identifying 13+ vulnerabilities using Burp Suite and Nmap, which\ncontributed to improving client data protection by up to 20%.\nProjects\nChinatsu in development | C++, GLFW, OpenGL, Glad, ImGui, premake, Box2D, spdlog 2024 \u2013 Present\n\u2022 Designing and implementing a game engine from scratch in C++ for Windows, focusing on custom graphics\nrendering, input systems, and real-time game development.\n\u2022 Integrating GLFW for window management and input, OpenGL for rendering, and ImGui for custom debugging\ntools and development interfaces. GitHub: brodante/Chinatsu\nSignOutSync in beta | Python, JavaScript 2024 \u2013 Present\n\u2022 Developing a Single Logout system that allows users to view and manage active logins across devices, as well as\nsubmit remote logout requests for compromised accounts and devices.\n\u2022 GitHub: brodante/SignOutSync, qualified for HacktoberFest 2024.\nKeyGuardian Developed, Maintained | Python(zlib, hashlib, fernet), C++ 2023 \u2013 2024\n\u2022 Python tool for hash creation, file/folder encryption, and decryption using Fernet (AES in CBC mode with a\n128-bit key), securely retrieving keys from default or specified directories for data decryption.\n\u2022 Github: brodante/KeyGuardian, Published Research Paper DOI: 10.55041/IJSREM34392\nSkills\nLanguages: C/C++, Python\nTools & Platforms: Visual Studio, VS Code, Burp Suite, OWASP ZAP, Nmap, sqlmap, Linux, Git, Postman\nFrameworks & Libraries: Metasploit, Fernet, Cryptopp, STL, fstream, system.OS\nSoft Skills: Adaptability, Curiosity, Analytical Thinking, Problem-Solving\nCertifications\nDIAT Certified Information Assurance Professional Verify.\nEthical Hacker by CISCO Verify.\nCyber Threat Management by CISCO Verify.\nIT Security Defense against the digital dark arts by Google Verify.\nAutomate Cybersecurity Tasks with Python by Google Verify.\nPut It to Work: Prepare for Cybersecurity Jobs by Google Verify.\nOperating Systems: Overview, Administration, and Security by IBM Verify.\nEducation\nRaj Kumar Goel Institute of Technology Ghaziabad, U.P\nBachelor of Technology in Computer Science and Engineering Nov. 2020 \u2013 July 2024\nLucknow Public School Lucknow, U.P.\nSenior Secondary Education (Class XII) 2017 \u2013 2019\n",
        "questions": [
            {
                "question": "Can you briefly walk me through your resume, highlighting your key experiences and projects that you're most proud of?",
                "subquestions": [
                    "What motivated you to pursue a career in cybersecurity and software development, and how do these fields complement each other in your work?",
                    "Looking back, what's one significant lesson you've learned from a challenging project or experience?"
                ]
            },
            {
                "question": "Your resume mentions developing firmware in C++ for wireless gaming mice. Can you describe the challenges you faced in achieving a stable 1000Hz polling rate and reducing the driver size by 35%?",
                "subquestions": [
                    "What specific techniques or optimizations did you implement to achieve this performance improvement? ",
                    "How did you ensure the stability of the firmware across different hardware configurations?"
                ]
            },
            {
                "question": "You led the Rust firmware development, optimizing wireless performance and reducing load time. Can you elaborate on your experience with Rust and the strategies you used for optimization?",
                "subquestions": [
                    "What were the key performance bottlenecks you identified, and how did you address them using Rust?",
                    "How did you manage the transition from C++ to Rust in the project, and what were the advantages and challenges of this shift?"
                ]
            },
            {
                "question": "Your project 'Chinatsu' involves building a game engine from scratch in C++. Can you discuss your design choices regarding custom graphics rendering and the challenges you encountered while working with OpenGL and integrating ImGui?",
                "subquestions": [
                    "What specific rendering techniques did you implement in your game engine and why did you choose them?",
                    "How did you manage memory management and performance optimization in a real-time environment like a game engine?"
                ]
            },
            {
                "question": "The 'SignOutSync' project utilizes both Python and JavaScript. Can you explain your architecture design for a single logout system and the technologies you used to ensure secure remote logout requests?",
                "subquestions": [
                    "How did you handle authentication and authorization in this system to ensure only authorized users could perform these actions?",
                    "How did you handle the scenario when the connection between client and server is broken in the midst of the logout process?"
                ]
            },
            {
                "question": "Your KeyGuardian project involves file encryption and decryption using Fernet.  Can you discuss your approach to secure key management and handling the potential security risks related to using AES in CBC mode?",
                "subquestions": [
                    "Why did you choose Fernet over other encryption libraries or methods? What were the trade-offs you considered?",
                    "How did you ensure the integrity and confidentiality of the keys used for encryption and decryption, especially when they are retrieved from default or specified directories?"
                ]
            }
        ],
        "solutions": [],
        "question_index": 6,
        "subquestion_index": -1,
        "current_answer": [],
        "answers": [
            "Thank you for the question. I'd be happy to walk you through my resume and highlight the experiences and projects I\u2019m most proud of.I'm Surya Pratap Singh Chauhan, a Computer Science graduate with a strong interest in systems programming, cybersecurity, and game development. Over the past few years, I\u2019ve worked on a range of technical projects and gained industry experience that helped me grow both as a developer and problem solver.",
            "My passion for cybersecurity and software development stems from a desire to build innovative solutions that are not only functional but also secure\u2014understanding how systems can be exploited drives me to write better, safer code, and combining both fields allows me to create robust applications with security built in from the ground up.",
            "One significant lesson I\u2019ve learned is that clear communication and early problem identification are critical\u2014during a group project, a misalignment in responsibilities caused delays, and it taught me the importance of regular check-ins, documentation, and collaborative planning to keep complex projects on track.",
            "Certainly! Achieving a stable 1000Hz polling rate in wireless gaming mice was challenging due to tight timing constraints and power limitations. I had to optimize USB communication protocols and minimize interrupt latency, ensuring consistent signal delivery without drops. Reducing the driver size by 35% involved eliminating redundant code, refactoring logic for efficiency, and using memory-efficient data structures, all while maintaining performance and compatibility across devices. Balancing speed, stability, and resource constraints was a key learning experience in embedded systems development.",
            "To achieve the performance improvements, I implemented several key techniques:Interrupt-Driven Architecture: Switched from polling to interrupt-driven input handling to reduce CPU usage and improve responsiveness.Code Refactoring & Modularization: Removed redundant logic, reused functions across modules, and optimized control flow to minimize instruction count.Memory Optimization: Used fixed-size buffers and packed data structures to reduce memory footprint and improve cache utilization. Low-Level USB Stack Tuning: Fine-tuned USB HID report intervals and minimized processing time in the ISR to maintain a stable 1000Hz polling rate.Compiler-Level Optimizations: Leveraged flags for size and speed (-Os, -O2) and inlined critical routines where beneficial.Bit-Level Manipulations: Used bit masking and shifting instead of larger arithmetic operations to speed up runtime computations.Custom Lightweight Driver Layer: Rewrote sections of the driver from scratch with a focus on minimalism, reducing code bloat while preserving functionality.",
            "To ensure firmware stability across different hardware configurations, I implemented thorough hardware abstraction layers that isolate device-specific code, enabling the core logic to remain consistent. I conducted extensive testing on multiple hardware variants using automated test suites and stress tests to identify and fix timing or compatibility issues early. Additionally, I incorporated robust error handling and fallback mechanisms to gracefully manage unexpected hardware behavior, and maintained close collaboration with hardware engineers to address any platform-specific nuances. This approach ensured reliable performance regardless of the underlying device differences.",
            "To ensure firmware stability across different hardware configurations, I designed hardware abstraction layers to isolate device-specific differences, enabling the core firmware to work uniformly. I performed extensive testing on various hardware versions, including stress and edge-case tests, and used modular code to quickly adapt to hardware changes. Additionally, I implemented robust error handling and collaborated closely with hardware teams to address compatibility issues early in the development cycle.",
            "Absolutely! Working with Rust for firmware development was a rewarding experience because of its strong memory safety guarantees and performance. To optimize wireless performance and reduce load time, I leveraged Rust\u2019s zero-cost abstractions to write efficient, low-level code without sacrificing safety. I used async programming and lightweight concurrency to handle wireless communication more effectively, minimizing latency. Additionally, I employed careful profiling to identify bottlenecks and optimized critical paths by reducing heap allocations and using stack-based data structures. Rust\u2019s tooling also helped catch bugs early, which improved overall stability and reduced debugging time during optimization.",
            "The key performance bottlenecks I identified were high latency in wireless packet processing and slow initialization times caused by excessive heap allocations. Using Rust, I addressed these issues by minimizing heap usage, opting for stack-allocated data structures and leveraging Rust\u2019s ownership system to avoid unnecessary cloning or allocations. I implemented asynchronous concurrency with lightweight futures to handle wireless I/O efficiently without blocking, and optimized critical loops using Rust\u2019s zero-cost abstractions to reduce overhead. Through profiling, I identified hot functions and inlined them to cut down call overhead and improve cache locality. Additionally, I used safe low-level bit manipulations to speed up protocol parsing while maintaining Rust\u2019s strong memory safety guarantees. These combined efforts significantly improved throughput and reduced load times.",
            "Managing the transition from C++ to Rust involved a gradual, modular approach where I first identified critical components that would benefit most from Rust\u2019s safety and performance features. I refactored these parts incrementally, ensuring compatibility with the existing C++ codebase through well-defined interfaces. The advantages included improved memory safety with Rust\u2019s ownership model, which drastically reduced bugs related to memory leaks and race conditions, as well as clearer and more maintainable code. However, the shift also posed challenges, such as a learning curve for the team unfamiliar with Rust\u2019s syntax and ownership concepts, and the need to adapt existing build and tooling processes. Balancing interoperability between C++ and Rust required careful design but ultimately resulted in a more robust and efficient firmware.",
            "Certainly! When designing Chinatsu, I focused on creating a flexible custom graphics rendering pipeline in C++ that could efficiently handle real-time rendering needs. I chose OpenGL for its wide support and relatively straightforward API, which allowed me to build low-level control over shaders, textures, and buffer management. One major design choice was to implement a modular renderer architecture, enabling easy swapping or upgrading of rendering components without affecting the entire engine.Working with OpenGL posed challenges like managing state changes efficiently to avoid performance hits and handling cross-platform compatibility issues. Debugging graphics bugs was also tricky due to limited error reporting in OpenGL, so I relied heavily on validation tools and careful resource management.Integrating ImGui was instrumental for rapid prototyping and debugging. The main challenge there was seamlessly embedding ImGui\u2019s rendering loop within my engine\u2019s render pipeline without causing frame drops or input conflicts. This required careful synchronization and managing ImGui\u2019s draw data alongside my own rendering commands. Overall, this experience deepened my understanding of graphics programming and real-time system integration.",
            "In my game engine, I implemented techniques like deferred shading to efficiently handle multiple light sources and improve rendering performance in complex scenes. I also used texture atlasing to reduce draw calls and optimize memory usage. For handling transparency and blending, I integrated alpha blending with depth sorting to ensure correct visual output. Additionally, I incorporated frustum culling to avoid rendering objects outside the camera\u2019s view, which helped boost frame rates. These choices balanced performance and visual quality, allowing the engine to scale well across different hardware while maintaining real-time responsiveness.",
            "In a real-time environment like a game engine, I managed memory carefully by using custom allocators and pooling strategies to minimize fragmentation and reduce allocation overhead during runtime. I prioritized stack allocation and reused buffers wherever possible to avoid frequent heap allocations. For performance optimization, I implemented techniques like object pooling for frequently created and destroyed entities, and employed efficient data structures that improve cache locality. Additionally, I used profiling tools to identify bottlenecks and optimized critical code paths, ensuring that rendering and game logic stayed within strict frame time budgets. This combination of proactive memory management and targeted optimization helped maintain smooth, consistent performance.",
            "Certainly! For the SignOutSync project, I designed a single logout system that coordinates user sign-out across multiple services seamlessly. The architecture centers around a secure token-based mechanism where the frontend (JavaScript) triggers logout requests, which are then propagated to backend services written in Python.To ensure secure remote logout requests, I used JWT tokens with short lifespans and included signed claims to verify authenticity. Communication between services happens over HTTPS with mutual TLS to prevent interception or spoofing. On the backend, each service validates the logout token before terminating sessions or clearing cookies. I also implemented centralized session management to track active sessions across services, enabling coordinated invalidation during logout.This design ensures that when a user logs out from one application, all related services receive and process the logout request securely and efficiently, providing a consistent user experience while maintaining strong security.",
            "In the SignOutSync system, authentication was managed using secure JWT tokens issued upon user login, which included user identity and role claims. Each logout request carried a signed token that backend services validated to confirm the requester\u2019s authenticity. To enforce authorization, services checked the user\u2019s roles and permissions encoded in the token before processing logout actions, ensuring only the legitimate user or trusted systems could trigger session invalidation. Additionally, all communications were secured with HTTPS and mutual TLS to prevent unauthorized access or tampering, creating a robust framework where only authorized users could perform logout operations.",
            "To handle connection interruptions during logout, I implemented a retry mechanism on the client side that attempts to resend the logout request a few times with exponential backoff. On the server side, logout requests are designed to be idempotent, meaning repeated requests won\u2019t cause inconsistent states or errors. Additionally, the system maintains a centralized session store, so even if the client disconnects mid-process, the server can detect stale or expired sessions and clean them up during periodic checks. This approach ensures the user\u2019s sessions are properly terminated despite temporary network failures, maintaining security and consistency.",
            "In the KeyGuardian project, I focused heavily on secure key management by generating strong, random keys using cryptographically secure libraries and storing them securely using environment variables or protected vaults rather than hardcoding them. The keys are rotated periodically to minimize exposure risk. For encryption, while Fernet uses AES in CBC mode under the hood, I mitigated CBC-related risks\u2014such as IV reuse and padding oracle attacks\u2014by relying on Fernet\u2019s built-in mechanisms that generate a fresh, random IV for each encryption and apply proper padding schemes. Additionally, Fernet includes built-in authentication (HMAC) to ensure ciphertext integrity and prevent tampering. Together, these measures help maintain confidentiality, integrity, and secure key handling throughout the encryption and decryption processes.",
            "I chose Fernet because it offers a high-level, easy-to-use API that combines AES encryption with built-in authentication (HMAC) to ensure both confidentiality and integrity, simplifying secure implementation without sacrificing safety. Fernet\u2019s design abstracts away many cryptographic complexities like IV management and padding, reducing the risk of developer errors. The trade-off was less flexibility compared to lower-level libraries, which might offer more control or support for other modes of operation, but for the project\u2019s goals\u2014secure, reliable file encryption with minimal risk\u2014Fernet struck the right balance between security and ease of use.",
            "To ensure the integrity and confidentiality of encryption keys stored in default or specified directories, I implemented strict file permission controls to restrict access only to authorized users and processes. The keys are stored in encrypted form whenever possible, and access to the directories is monitored and audited. Additionally, I used checksums and HMACs to verify the keys\u2019 integrity before use, detecting any tampering or corruption. When loading keys, I applied secure handling practices such as zeroing out key material from memory after use to minimize exposure. Together, these measures protect the keys from unauthorized access and ensure they remain trustworthy throughout their lifecycle."
        ],
        "question_asked": "How did you ensure the integrity and confidentiality of the keys used for encryption and decryption, especially when they are retrieved from default or specified directories?",
        "job_description": "",
        "satisfactory_till_now": true
    }
}